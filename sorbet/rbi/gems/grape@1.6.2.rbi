# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `grape` gem.
# Please instead update this file by running `bin/tapioca gem grape`.

module DryTypes
  extend ::Dry::Types::BuilderMethods
  extend ::Dry::Core::Deprecations::Interface

  mixes_in_class_methods ::Dry::Types::BuilderMethods
end

module Grape
  extend ::ActiveSupport::Autoload
  extend ::Grape::Config

  class << self
    def config; end
    def configure; end
  end
end

class Grape::API
  extend ::ActiveSupport::Autoload

  class << self
    def base_instance; end
    def base_instance=(_arg0); end
    def call(*args, &block); end
    def compile!; end
    def configure; end
    def const_missing(*args); end
    def inherited(api); end
    def initial_setup(base_instance_parent); end
    def instances; end
    def instances=(_arg0); end
    def method_missing(method, *args, &block); end
    def mount_instance(**opts); end
    def new(*args, &block); end
    def override_all_methods!; end
    def replay_setup_on(instance); end
    def respond_to?(method, include_private = T.unsafe(nil)); end
    def respond_to_missing?(method, include_private = T.unsafe(nil)); end

    private

    def add_setup(method, *args, &block); end
    def any_lazy?(args); end
    def evaluate_arguments(configuration, *args); end
    def instance_for_rack; end
    def mounted_instances; end
    def never_mounted?; end
    def replay_step_on(instance, setup_step); end
    def skip_immediate_run?(instance, args); end
  end
end

class Grape::API::Boolean
  class << self
    def build(val); end
  end
end

module Grape::API::Helpers
  include ::Grape::DSL::Helpers::BaseHelper
end

class Grape::API::Instance
  include ::Grape::Middleware::Auth::DSL
  include ::Grape::DSL::Configuration
  include ::Grape::DSL::Validations
  include ::Grape::DSL::Callbacks
  include ::Grape::DSL::Helpers
  include ::Grape::DSL::Middleware
  include ::Grape::DSL::RequestResponse
  include ::Grape::DSL::Routing
  include ::Grape::DSL::API
  extend ::Grape::Middleware::Auth::DSL::ClassMethods
  extend ::Grape::DSL::Settings
  extend ::Grape::DSL::Logger
  extend ::Grape::DSL::Desc
  extend ::Grape::DSL::Configuration::ClassMethods
  extend ::Grape::DSL::Validations::ClassMethods
  extend ::Grape::DSL::Callbacks::ClassMethods
  extend ::Grape::DSL::Helpers::ClassMethods
  extend ::Grape::DSL::Middleware::ClassMethods
  extend ::Grape::DSL::RequestResponse::ClassMethods
  extend ::Grape::DSL::Routing::ClassMethods

  def initialize; end

  def call(env); end
  def cascade?; end
  def router; end

  private

  def add_head_not_allowed_methods_and_options_methods; end
  def collect_route_config_per_pattern; end
  def generate_not_allowed_method(pattern, allowed_methods: T.unsafe(nil), **attributes); end
  def without_root_prefix(&_block); end
  def without_versioning(&_block); end

  class << self
    def base; end
    def base=(grape_api); end
    def base_instance?; end
    def call(env); end
    def call!(env); end
    def cascade(value = T.unsafe(nil)); end
    def change!; end
    def compile; end
    def compile!; end
    def configuration; end
    def configuration=(_arg0); end
    def given(conditional_option, &block); end
    def instance; end
    def mounted(&block); end
    def recognize_path(path); end
    def reset!; end
    def to_s; end

    protected

    def evaluate_as_instance_with_configuration(block, lazy: T.unsafe(nil)); end
    def inherit_settings(other_settings); end
    def inherited(subclass); end
    def nest(*blocks, &block); end
    def prepare_routes; end
  end
end

Grape::API::Instance::Boolean = Grape::API::Boolean
Grape::API::NON_OVERRIDABLE = T.let(T.unsafe(nil), Array)

module Grape::Config
  class << self
    def extended(base); end
  end
end

class Grape::Config::Configuration
  def initialize; end

  def param_builder; end
  def param_builder=(_arg0); end
  def reset; end
end

Grape::Config::Configuration::ATTRIBUTES = T.let(T.unsafe(nil), Array)

module Grape::ContentTypes
  extend ::Grape::Util::Registrable

  class << self
    def content_types_for(from_settings); end
    def content_types_for_settings(settings); end
  end
end

Grape::ContentTypes::CONTENT_TYPES = T.let(T.unsafe(nil), Hash)

class Grape::Cookies
  def initialize; end

  def [](name); end
  def []=(name, value); end
  def delete(name, **opts); end
  def each(&block); end
  def read(request); end
  def write(header); end
end

module Grape::DSL
  extend ::ActiveSupport::Autoload
end

module Grape::DSL::API
  extend ::ActiveSupport::Concern
  include ::Grape::Middleware::Auth::DSL
  include ::Grape::DSL::Configuration
  include ::Grape::DSL::Validations
  include ::Grape::DSL::Callbacks
  include ::Grape::DSL::Helpers
  include ::Grape::DSL::Middleware
  include ::Grape::DSL::RequestResponse
  include ::Grape::DSL::Routing

  mixes_in_class_methods ::Grape::Middleware::Auth::DSL::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Validations::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Callbacks::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Helpers::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Middleware::ClassMethods
  mixes_in_class_methods ::Grape::DSL::RequestResponse::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Routing::ClassMethods
end

module Grape::DSL::Callbacks
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Configuration

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Callbacks::ClassMethods
end

module Grape::DSL::Callbacks::ClassMethods
  def after(&block); end
  def after_validation(&block); end
  def before(&block); end
  def before_validation(&block); end
  def finally(&block); end
end

module Grape::DSL::Configuration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
end

module Grape::DSL::Configuration::ClassMethods
  include ::Grape::DSL::Settings
  include ::Grape::DSL::Logger
  include ::Grape::DSL::Desc
end

module Grape::DSL::Desc
  include ::Grape::DSL::Settings

  def desc(description, options = T.unsafe(nil), &config_block); end
  def desc_container(endpoint_configuration); end
  def description_field(field, value = T.unsafe(nil)); end
  def unset_description_field(field); end
end

module Grape::DSL::Headers
  def header(key = T.unsafe(nil), val = T.unsafe(nil)); end
  def headers(key = T.unsafe(nil), val = T.unsafe(nil)); end
end

module Grape::DSL::Helpers
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Configuration

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Helpers::ClassMethods
end

module Grape::DSL::Helpers::BaseHelper
  def api; end
  def api=(_arg0); end
  def api_changed(new_api); end
  def params(name, &block); end

  protected

  def process_named_params; end
end

module Grape::DSL::Helpers::ClassMethods
  def helpers(*new_modules, &block); end

  protected

  def define_boolean_in_mod(mod); end
  def include_all_in_scope; end
  def include_block(block); end
  def include_new_modules(modules); end
  def inject_api_helpers_to_mod(mod, &block); end
  def make_inclusion(mod, &block); end
end

module Grape::DSL::InsideRoute
  include ::Grape::DSL::Headers
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Settings

  def body(value = T.unsafe(nil)); end
  def configuration; end
  def content_type(val = T.unsafe(nil)); end
  def cookies; end
  def declared(*_arg0); end
  def entity_class_for_obj(object, options); end
  def entity_representation_for(entity_class, object, options); end
  def error!(message, status = T.unsafe(nil), additional_headers = T.unsafe(nil)); end
  def file(value = T.unsafe(nil)); end
  def present(*args); end
  def redirect(url, permanent: T.unsafe(nil), body: T.unsafe(nil), **_options); end
  def return_no_content; end
  def route; end
  def sendfile(value = T.unsafe(nil)); end
  def status(status = T.unsafe(nil)); end
  def stream(value = T.unsafe(nil)); end
  def version; end

  class << self
    def post_filter_methods(type); end
  end
end

class Grape::DSL::InsideRoute::MethodNotYetAvailable < ::StandardError; end

module Grape::DSL::InsideRoute::PostBeforeFilter
  def declared(passed_params, options = T.unsafe(nil), declared_params = T.unsafe(nil), params_nested_path = T.unsafe(nil)); end

  private

  def declared_array(passed_params, options, declared_params, params_nested_path); end
  def declared_hash(passed_params, options, declared_params, params_nested_path); end
  def handle_passed_param(params_nested_path, has_passed_children = T.unsafe(nil), &_block); end
  def optioned_declared_params(**options); end
  def optioned_param_key(declared_param, options); end
end

module Grape::DSL::Logger
  include ::Grape::DSL::Settings

  def logger(logger = T.unsafe(nil)); end
  def logger=(_arg0); end
end

module Grape::DSL::Middleware
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Configuration

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Middleware::ClassMethods
end

module Grape::DSL::Middleware::ClassMethods
  def insert(*args, &block); end
  def insert_after(*args, &block); end
  def insert_before(*args, &block); end
  def middleware; end
  def use(middleware_class, *args, &block); end
end

module Grape::DSL::Parameters
  extend ::ActiveSupport::Concern

  def all_or_none_of(*attrs); end
  def at_least_one_of(*attrs); end
  def build_with(build_with = T.unsafe(nil)); end
  def declared_param?(param); end
  def exactly_one_of(*attrs); end
  def given(*attrs, &block); end
  def group(*attrs, &block); end
  def includes(*names); end
  def map_params(params, element, is_array = T.unsafe(nil)); end
  def mutually_exclusive(*attrs); end
  def optional(*attrs, &block); end
  def params(params); end
  def requires(*attrs, &block); end
  def use(*names); end
  def use_scope(*names); end
  def with(*attrs, &block); end

  private

  def first_hash_key_or_param(parameter); end
end

class Grape::DSL::Parameters::EmptyOptionalValue; end

module Grape::DSL::RequestResponse
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Configuration

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::RequestResponse::ClassMethods
end

module Grape::DSL::RequestResponse::ClassMethods
  def content_type(key, val); end
  def content_types; end
  def default_error_formatter(new_formatter_name = T.unsafe(nil)); end
  def default_error_status(new_status = T.unsafe(nil)); end
  def default_format(new_format = T.unsafe(nil)); end
  def error_formatter(format, options); end
  def format(new_format = T.unsafe(nil)); end
  def formatter(content_type, new_formatter); end
  def parser(content_type, new_parser); end
  def represent(model_class, options); end
  def rescue_from(*args, &block); end

  private

  def extract_with(options); end
end

module Grape::DSL::Routing
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Configuration

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Routing::ClassMethods
end

module Grape::DSL::Routing::ClassMethods
  def delete(*args, &block); end
  def do_not_route_head!; end
  def do_not_route_options!; end
  def endpoints; end
  def get(*args, &block); end
  def group(space = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def head(*args, &block); end
  def mount(mounts, *opts); end
  def namespace(space = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def options(*args, &block); end
  def patch(*args, &block); end
  def post(*args, &block); end
  def prefix(prefix = T.unsafe(nil)); end
  def put(*args, &block); end
  def reset_endpoints!; end
  def reset_routes!; end
  def resource(space = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def resources(space = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def route(methods, paths = T.unsafe(nil), route_options = T.unsafe(nil), &block); end
  def route_param(param, options = T.unsafe(nil), &block); end
  def routes; end
  def scope(_name = T.unsafe(nil), &block); end
  def segment(space = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def version(*args, &block); end
  def versions; end
end

module Grape::DSL::Settings
  extend ::ActiveSupport::Concern

  def api_class_setting(key, value = T.unsafe(nil)); end
  def get_or_set(type, key, value); end
  def global_setting(key, value = T.unsafe(nil)); end
  def inheritable_setting; end
  def inheritable_setting=(_arg0); end
  def namespace_end; end
  def namespace_inheritable(key, value = T.unsafe(nil)); end
  def namespace_inheritable_to_nil(key); end
  def namespace_reverse_stackable(key, value = T.unsafe(nil)); end
  def namespace_reverse_stackable_with_hash(key); end
  def namespace_setting(key, value = T.unsafe(nil)); end
  def namespace_stackable(key, value = T.unsafe(nil)); end
  def namespace_stackable_with_hash(key); end
  def namespace_start; end
  def route_end; end
  def route_setting(key, value = T.unsafe(nil)); end
  def top_level_setting; end
  def top_level_setting=(_arg0); end
  def unset(type, key); end
  def unset_api_class_setting(key); end
  def unset_global_setting(key); end
  def unset_namespace_inheritable(key); end
  def unset_namespace_setting(key); end
  def unset_namespace_stackable(key); end
  def unset_route_setting(key); end
  def within_namespace(&block); end

  private

  def build_top_level_setting; end
end

module Grape::DSL::Validations
  extend ::ActiveSupport::Concern
  include ::Grape::DSL::Configuration

  mixes_in_class_methods ::Grape::DSL::Configuration::ClassMethods
  mixes_in_class_methods ::Grape::DSL::Validations::ClassMethods
end

module Grape::DSL::Validations::ClassMethods
  def document_attribute(names, opts); end
  def params(&block); end
  def reset_validations!; end
end

class Grape::Endpoint
  include ::Grape::DSL::Settings
  include ::Grape::DSL::Headers
  include ::Grape::DSL::InsideRoute

  def initialize(new_settings, options = T.unsafe(nil), &block); end

  def block; end
  def block=(_arg0); end
  def call(env); end
  def call!(env); end
  def endpoints; end
  def env; end
  def equals?(e); end
  def headers; end
  def inherit_settings(namespace_stackable); end
  def map_routes; end
  def merge_route_options(**default); end
  def method_name; end
  def mount_in(router); end
  def namespace; end
  def options; end
  def options=(_arg0); end
  def params; end
  def prepare_default_route_attributes; end
  def prepare_path(path); end
  def prepare_routes_requirements; end
  def prepare_version; end
  def request; end
  def require_option(options, key); end
  def reset_routes!; end
  def routes; end
  def source; end
  def source=(_arg0); end
  def to_routes; end

  protected

  def after_validations; end
  def afters; end
  def before_validations; end
  def befores; end
  def execute; end
  def finallies; end
  def helpers; end
  def lazy_initialize!; end
  def options?; end
  def run; end
  def run_filters(filters, type = T.unsafe(nil)); end
  def run_validators(validator_factories, request); end
  def validations; end

  private

  def build_helpers; end
  def build_stack(helpers); end

  class << self
    def before_each(new_setup = T.unsafe(nil), &block); end
    def generate_api_method(method_name, &block); end
    def new(*args, &block); end
    def run_before_each(endpoint); end
  end
end

module Grape::Env; end
Grape::Env::API_ENDPOINT = T.let(T.unsafe(nil), String)
Grape::Env::API_FORMAT = T.let(T.unsafe(nil), String)
Grape::Env::API_REQUEST_BODY = T.let(T.unsafe(nil), String)
Grape::Env::API_REQUEST_INPUT = T.let(T.unsafe(nil), String)
Grape::Env::API_SUBTYPE = T.let(T.unsafe(nil), String)
Grape::Env::API_TYPE = T.let(T.unsafe(nil), String)
Grape::Env::API_VENDOR = T.let(T.unsafe(nil), String)
Grape::Env::API_VERSION = T.let(T.unsafe(nil), String)
Grape::Env::GRAPE_ALLOWED_METHODS = T.let(T.unsafe(nil), String)
Grape::Env::GRAPE_REQUEST = T.let(T.unsafe(nil), String)
Grape::Env::GRAPE_REQUEST_HEADERS = T.let(T.unsafe(nil), String)
Grape::Env::GRAPE_REQUEST_PARAMS = T.let(T.unsafe(nil), String)
Grape::Env::GRAPE_ROUTING_ARGS = T.let(T.unsafe(nil), String)
Grape::Env::RACK_INPUT = T.let(T.unsafe(nil), String)
Grape::Env::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Grape::Env::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Grape::Env::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

module Grape::ErrorFormatter
  extend ::Grape::Util::Registrable
  extend ::ActiveSupport::Autoload

  class << self
    def builtin_formatters; end
    def formatter_for(api_format, **options); end
    def formatters(**options); end
  end
end

module Grape::ErrorFormatter::Base
  def present(message, env); end
end

module Grape::ErrorFormatter::Json
  extend ::Grape::ErrorFormatter::Base

  class << self
    def call(message, backtrace, options = T.unsafe(nil), env = T.unsafe(nil), original_exception = T.unsafe(nil)); end

    private

    def wrap_message(message); end
  end
end

module Grape::ErrorFormatter::Txt
  extend ::Grape::ErrorFormatter::Base

  class << self
    def call(message, backtrace, options = T.unsafe(nil), env = T.unsafe(nil), original_exception = T.unsafe(nil)); end
  end
end

module Grape::ErrorFormatter::Xml
  extend ::Grape::ErrorFormatter::Base

  class << self
    def call(message, backtrace, options = T.unsafe(nil), env = T.unsafe(nil), original_exception = T.unsafe(nil)); end
  end
end

module Grape::Exceptions
  extend ::ActiveSupport::Autoload
end

class Grape::Exceptions::Base < ::StandardError
  def initialize(status: T.unsafe(nil), message: T.unsafe(nil), headers: T.unsafe(nil), **_options); end

  def [](index); end
  def headers; end
  def message; end
  def status; end

  protected

  def compose_message(key, **attributes); end
  def fallback_message(key, **options); end
  def problem(key, **attributes); end
  def resolution(key, **attributes); end
  def summary(key, **attributes); end
  def translate(key, **options); end
  def translate_attributes(keys, **options); end
  def translate_message(key, **options); end
end

Grape::Exceptions::Base::BASE_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)
Grape::Exceptions::Base::BASE_MESSAGES_KEY = T.let(T.unsafe(nil), String)
Grape::Exceptions::Base::FALLBACK_LOCALE = T.let(T.unsafe(nil), Symbol)

class Grape::Exceptions::EmptyMessageBody < ::Grape::Exceptions::Base
  def initialize(body_format); end
end

class Grape::Exceptions::IncompatibleOptionValues < ::Grape::Exceptions::Base
  def initialize(option1, value1, option2, value2); end
end

class Grape::Exceptions::InvalidAcceptHeader < ::Grape::Exceptions::Base
  def initialize(message, headers); end
end

class Grape::Exceptions::InvalidFormatter < ::Grape::Exceptions::Base
  def initialize(klass, to_format); end
end

class Grape::Exceptions::InvalidMessageBody < ::Grape::Exceptions::Base
  def initialize(body_format); end
end

class Grape::Exceptions::InvalidResponse < ::Grape::Exceptions::Base
  def initialize; end
end

class Grape::Exceptions::InvalidVersionHeader < ::Grape::Exceptions::Base
  def initialize(message, headers); end
end

class Grape::Exceptions::InvalidVersionerOption < ::Grape::Exceptions::Base
  def initialize(strategy); end
end

class Grape::Exceptions::InvalidWithOptionForRepresent < ::Grape::Exceptions::Base
  def initialize; end
end

class Grape::Exceptions::MethodNotAllowed < ::Grape::Exceptions::Base
  def initialize(headers); end
end

class Grape::Exceptions::MissingGroupTypeError < ::Grape::Exceptions::Base
  def initialize; end
end

class Grape::Exceptions::MissingMimeType < ::Grape::Exceptions::Base
  def initialize(new_format); end
end

class Grape::Exceptions::MissingOption < ::Grape::Exceptions::Base
  def initialize(option); end
end

class Grape::Exceptions::MissingVendorOption < ::Grape::Exceptions::Base
  def initialize; end
end

class Grape::Exceptions::UnknownOptions < ::Grape::Exceptions::Base
  def initialize(options); end
end

class Grape::Exceptions::UnknownParameter < ::Grape::Exceptions::Base
  def initialize(param); end
end

class Grape::Exceptions::UnknownValidator < ::Grape::Exceptions::Base
  def initialize(validator_type); end
end

class Grape::Exceptions::UnsupportedGroupTypeError < ::Grape::Exceptions::Base
  def initialize; end
end

class Grape::Exceptions::Validation < ::Grape::Exceptions::Base
  def initialize(params:, message: T.unsafe(nil), **args); end

  def as_json(*_args); end
  def message_key; end
  def message_key=(_arg0); end
  def params; end
  def params=(_arg0); end
  def to_s; end
end

class Grape::Exceptions::ValidationArrayErrors < ::Grape::Exceptions::Base
  def initialize(errors); end

  def errors; end
end

class Grape::Exceptions::ValidationErrors < ::Grape::Exceptions::Base
  include ::Enumerable

  def initialize(errors: T.unsafe(nil), headers: T.unsafe(nil), **_options); end

  def as_json(**_opts); end
  def each; end
  def errors; end
  def full_messages; end
  def to_json(*_opts); end
end

Grape::Exceptions::ValidationErrors::DEFAULT_ERRORS_FORMAT = T.let(T.unsafe(nil), String)
Grape::Exceptions::ValidationErrors::ERRORS_FORMAT_KEY = T.let(T.unsafe(nil), String)

module Grape::Extensions
  extend ::ActiveSupport::Autoload
end

module Grape::Extensions::ActiveSupport
  extend ::ActiveSupport::Autoload
end

module Grape::Extensions::ActiveSupport::HashWithIndifferentAccess; end

module Grape::Extensions::ActiveSupport::HashWithIndifferentAccess::ParamBuilder
  extend ::ActiveSupport::Concern

  def build_params; end
  def params_builder; end
end

class Grape::Extensions::DeepMergeableHash < ::Hash
  def deep_merge!(other_hash); end
end

module Grape::Extensions::DeepSymbolizeHash
  class << self
    def deep_symbolize_keys_in(object); end
    def symbolize_key(key); end
  end
end

module Grape::Extensions::Hash; end

module Grape::Extensions::Hash::ParamBuilder
  extend ::ActiveSupport::Concern

  def build_params; end
  def post_process_params(params); end
end

module Grape::Extensions::Hashie
  extend ::ActiveSupport::Autoload
end

module Grape::Extensions::Hashie::Mash; end

module Grape::Extensions::Hashie::Mash::ParamBuilder
  extend ::ActiveSupport::Concern

  def build_params; end
  def params_builder; end
end

module Grape::Formatter
  extend ::Grape::Util::Registrable
  extend ::ActiveSupport::Autoload

  class << self
    def builtin_formatters; end
    def formatter_for(api_format, **options); end
    def formatters(**options); end
  end
end

module Grape::Formatter::Json
  class << self
    def call(object, _env); end
  end
end

module Grape::Formatter::SerializableHash
  class << self
    def call(object, _env); end

    private

    def serializable?(object); end
    def serialize(object); end
  end
end

module Grape::Formatter::Txt
  class << self
    def call(object, _env); end
  end
end

module Grape::Formatter::Xml
  class << self
    def call(object, _env); end
  end
end

module Grape::Http
  extend ::ActiveSupport::Autoload
end

module Grape::Http::Headers
  class << self
    def find_supported_method(route_method); end
  end
end

Grape::Http::Headers::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Grape::Http::Headers::DELETE = T.let(T.unsafe(nil), String)
Grape::Http::Headers::FORMAT = T.let(T.unsafe(nil), String)
Grape::Http::Headers::GET = T.let(T.unsafe(nil), String)
Grape::Http::Headers::HEAD = T.let(T.unsafe(nil), String)
Grape::Http::Headers::HTTP_ACCEPT = T.let(T.unsafe(nil), String)
Grape::Http::Headers::HTTP_ACCEPT_VERSION = T.let(T.unsafe(nil), String)
Grape::Http::Headers::HTTP_HEADERS = T.let(T.unsafe(nil), Grape::Util::LazyObject)
Grape::Http::Headers::HTTP_TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Grape::Http::Headers::HTTP_VERSION = T.let(T.unsafe(nil), String)
Grape::Http::Headers::OPTIONS = T.let(T.unsafe(nil), String)
Grape::Http::Headers::PATCH = T.let(T.unsafe(nil), String)
Grape::Http::Headers::PATH_INFO = T.let(T.unsafe(nil), String)
Grape::Http::Headers::POST = T.let(T.unsafe(nil), String)
Grape::Http::Headers::PUT = T.let(T.unsafe(nil), String)
Grape::Http::Headers::QUERY_STRING = T.let(T.unsafe(nil), String)
Grape::Http::Headers::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Grape::Http::Headers::SUPPORTED_METHODS = T.let(T.unsafe(nil), Array)
Grape::Http::Headers::SUPPORTED_METHODS_WITHOUT_OPTIONS = T.let(T.unsafe(nil), Grape::Util::LazyObject)
Grape::Http::Headers::X_CASCADE = T.let(T.unsafe(nil), String)
Grape::Json = JSON

module Grape::Middleware
  extend ::ActiveSupport::Autoload
end

module Grape::Middleware::Auth
  extend ::ActiveSupport::Autoload
end

class Grape::Middleware::Auth::Base
  include ::Grape::Middleware::Helpers

  def initialize(app, *options); end

  def _call(env); end
  def app; end
  def app=(_arg0); end
  def call(env); end
  def env; end
  def env=(_arg0); end
  def options; end
  def options=(_arg0); end
end

module Grape::Middleware::Auth::DSL
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Grape::Middleware::Auth::DSL::ClassMethods
end

module Grape::Middleware::Auth::DSL::ClassMethods
  def auth(type = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def http_basic(options = T.unsafe(nil), &block); end
  def http_digest(options = T.unsafe(nil), &block); end
end

module Grape::Middleware::Auth::Strategies
  private

  def [](label); end
  def add(label, strategy, option_fetcher = T.unsafe(nil)); end
  def auth_strategies; end

  class << self
    def [](label); end
    def add(label, strategy, option_fetcher = T.unsafe(nil)); end
    def auth_strategies; end
  end
end

class Grape::Middleware::Auth::StrategyInfo < ::Struct
  def auth_class; end
  def auth_class=(_); end
  def create(app, options, &block); end
  def settings_fetcher; end
  def settings_fetcher=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Grape::Middleware::Base
  include ::Grape::Middleware::Helpers
  include ::Grape::DSL::Headers

  def initialize(app, *options); end

  def after; end
  def app; end
  def before; end
  def call(env); end
  def call!(env); end
  def content_type; end
  def content_type_for(format); end
  def content_types; end
  def default_options; end
  def env; end
  def mime_types; end
  def options; end
  def response; end

  private

  def merge_headers(response); end
end

Grape::Middleware::Base::TEXT_HTML = T.let(T.unsafe(nil), String)

class Grape::Middleware::Error < ::Grape::Middleware::Base
  def initialize(app, *options); end

  def call!(env); end
  def default_options; end
  def default_rescue_handler(e); end
  def error!(message, status = T.unsafe(nil), headers = T.unsafe(nil), backtrace = T.unsafe(nil), original_exception = T.unsafe(nil)); end
  def error_response(error = T.unsafe(nil)); end
  def format_message(message, backtrace, original_exception = T.unsafe(nil)); end
  def rack_response(message, status = T.unsafe(nil), headers = T.unsafe(nil)); end

  private

  def rescue_handler_for_any_class(klass); end
  def rescue_handler_for_base_only_class(klass); end
  def rescue_handler_for_class_or_its_ancestor(klass); end
  def rescue_handler_for_grape_exception(klass); end
  def run_rescue_handler(handler, error); end
end

class Grape::Middleware::Formatter < ::Grape::Middleware::Base
  def after; end
  def before; end
  def default_options; end

  private

  def build_formatted_response(status, headers, bodies); end
  def ensure_content_type(headers); end
  def fetch_formatter(headers, options); end
  def format_from_extension; end
  def format_from_header; end
  def format_from_params; end
  def mime_array; end
  def negotiate_content_type; end
  def read_body_input; end
  def read_rack_input(body); end
  def request; end
end

Grape::Middleware::Formatter::CHUNKED = T.let(T.unsafe(nil), String)

class Grape::Middleware::Globals < ::Grape::Middleware::Base
  def before; end
end

module Grape::Middleware::Helpers
  def context; end
end

class Grape::Middleware::Stack
  include ::Enumerable

  def initialize; end

  def [](i); end
  def build(builder = T.unsafe(nil)); end
  def concat(other_specs); end
  def each(&block); end
  def insert(index, *args, **_arg2, &block); end
  def insert_after(index, *args, **_arg2, &block); end
  def insert_before(index, *args, **_arg2, &block); end
  def last; end
  def merge_with(middleware_specs); end
  def middlewares; end
  def middlewares=(_arg0); end
  def others; end
  def others=(_arg0); end
  def size; end
  def use(*args, **_arg1, &block); end

  protected

  def assert_index(index, where); end
end

class Grape::Middleware::Stack::Middleware
  def initialize(klass, *args, &block); end

  def ==(other); end
  def args; end
  def block; end
  def inspect; end
  def klass; end
  def name; end
  def use_in(builder); end
end

module Grape::Middleware::Versioner
  extend ::ActiveSupport::Autoload

  private

  def using(strategy); end

  class << self
    def using(strategy); end
  end
end

class Grape::Middleware::Versioner::AcceptVersionHeader < ::Grape::Middleware::Base
  def before; end

  private

  def cascade?; end
  def error_headers; end
  def strict?; end
  def versions; end
end

class Grape::Middleware::Versioner::Header < ::Grape::Middleware::Base
  def before; end

  private

  def an_accept_header_with_version_and_vendor_is_present?; end
  def available_media_types; end
  def cascade?; end
  def error_headers; end
  def fail_with_invalid_accept_header!(message); end
  def fail_with_invalid_version_header!(message); end
  def header; end
  def headers_contain_wrong_vendor?; end
  def headers_contain_wrong_version?; end
  def media_type; end
  def media_type_header_handler; end
  def rack_accept_header; end
  def request_vendor(media_type); end
  def request_version(media_type); end
  def strict?; end
  def strict_accept_header_presence_check; end
  def strict_header_checks; end
  def strict_version_vendor_accept_header_presence_check; end
  def vendor; end
  def vendor?(media_type); end
  def version?(media_type); end
  def version_options; end
  def versions; end
end

Grape::Middleware::Versioner::Header::HAS_VENDOR_REGEX = T.let(T.unsafe(nil), Regexp)
Grape::Middleware::Versioner::Header::HAS_VERSION_REGEX = T.let(T.unsafe(nil), Regexp)
Grape::Middleware::Versioner::Header::VENDOR_VERSION_HEADER_REGEX = T.let(T.unsafe(nil), Regexp)

class Grape::Middleware::Versioner::Param < ::Grape::Middleware::Base
  def before; end
  def default_options; end

  private

  def paramkey; end
  def version_options; end
end

class Grape::Middleware::Versioner::Path < ::Grape::Middleware::Base
  def before; end
  def default_options; end

  private

  def mount_path; end
  def mounted_path?(path); end
  def prefix; end
end

class Grape::Namespace
  def initialize(space, **options); end

  def options; end
  def requirements; end
  def space; end

  class << self
    def joined_space(settings); end
    def joined_space_path(settings); end
  end
end

class Grape::Namespace::JoinedSpaceCache < ::Grape::Util::Cache
  def initialize; end
end

module Grape::Parser
  extend ::Grape::Util::Registrable
  extend ::ActiveSupport::Autoload

  class << self
    def builtin_parsers; end
    def parser_for(api_format, **options); end
    def parsers(**options); end
  end
end

module Grape::Parser::Json
  class << self
    def call(object, _env); end
  end
end

module Grape::Parser::Xml
  class << self
    def call(object, _env); end
  end
end

class Grape::Path
  def initialize(raw_path, namespace, settings); end

  def mount_path; end
  def namespace; end
  def namespace?; end
  def path; end
  def path?; end
  def path_with_suffix; end
  def raw_path; end
  def root_prefix; end
  def settings; end
  def suffix; end
  def to_s; end
  def uses_path_versioning?; end
  def uses_specific_format?; end

  private

  def parts; end
  def split_setting(key); end

  class << self
    def prepare(raw_path, namespace, settings); end
  end
end

class Grape::Path::PartsCache < ::Grape::Util::Cache
  def initialize; end
end

module Grape::Presenters
  extend ::ActiveSupport::Autoload
end

class Grape::Presenters::Presenter
  class << self
    def represent(object, **_options); end
  end
end

class Grape::Request < ::Rack::Request
  def initialize(env, **options); end

  def headers; end
  def params; end
  def rack_params; end

  private

  def build_headers; end
  def grape_routing_args; end
  def transform_header(header); end
end

Grape::Request::HTTP_PREFIX = T.let(T.unsafe(nil), String)

class Grape::Router
  def initialize; end

  def append(route); end
  def associate_routes(pattern, **options); end
  def call(env); end
  def compile!; end
  def compiled; end
  def map; end
  def recognize_path(input); end

  private

  def call_with_allow_headers(env, route); end
  def cascade?(response); end
  def default_response; end
  def extract_input_and_method(env); end
  def greedy_match?(input); end
  def identity(env); end
  def make_routing_args(default_args, route, input); end
  def match?(input, method); end
  def prepare_env_from_route(env, route); end
  def process_route(route, env); end
  def rotation(env, exact_route = T.unsafe(nil)); end
  def string_for(input); end
  def transaction(env); end
  def with_optimization; end

  class << self
    def normalize_path(path); end
    def supported_methods; end
  end
end

class Grape::Router::AttributeTranslator
  def initialize(**attributes); end

  def attributes; end
  def description; end
  def details; end
  def entity; end
  def format; end
  def headers; end
  def http_codes; end
  def index; end
  def method_missing(method_name, *args); end
  def namespace; end
  def pattern; end
  def prefix; end
  def request_method; end
  def requirements; end
  def settings; end
  def to_h; end
  def version; end

  private

  def respond_to_missing?(method_name, _include_private = T.unsafe(nil)); end
  def setter?(method_name); end
end

Grape::Router::AttributeTranslator::ROUTER_ATTRIBUTES = T.let(T.unsafe(nil), Array)
Grape::Router::AttributeTranslator::ROUTE_ATTRIBUTES = T.let(T.unsafe(nil), Array)

class Grape::Router::Pattern
  extend ::Forwardable

  def initialize(pattern, **options); end

  def ===(*args, **_arg1, &block); end
  def match?(*args, **_arg1, &block); end
  def named_captures(*args, **_arg1, &block); end
  def origin; end
  def params(*args, **_arg1, &block); end
  def path; end
  def pattern; end
  def to_regexp; end

  private

  def build_path(pattern, anchor: T.unsafe(nil), suffix: T.unsafe(nil), **_options); end
  def extract_capture(requirements: T.unsafe(nil), **options); end
  def pattern_options(options); end
end

Grape::Router::Pattern::DEFAULT_PATTERN_OPTIONS = T.let(T.unsafe(nil), Hash)
Grape::Router::Pattern::DEFAULT_SUPPORTED_CAPTURE = T.let(T.unsafe(nil), Array)

class Grape::Router::Pattern::PatternCache < ::Grape::Util::Cache
  def initialize; end
end

class Grape::Router::Route
  extend ::Forwardable

  def initialize(method, pattern, **options); end

  def app; end
  def app=(_arg0); end
  def apply(app); end
  def attributes; end
  def description(*args, **_arg1, &block); end
  def details(*args, **_arg1, &block); end
  def entity(*args, **_arg1, &block); end
  def exec(env); end
  def format(*args, **_arg1, &block); end
  def headers(*args, **_arg1, &block); end
  def http_codes(*args, **_arg1, &block); end
  def index; end
  def index=(_arg0); end
  def match?(input); end
  def method_missing(method_id, *arguments); end
  def namespace(*args, **_arg1, &block); end
  def options; end
  def options=(_arg0); end
  def origin(*args, **_arg1, &block); end
  def params(input = T.unsafe(nil)); end
  def path(*args, **_arg1, &block); end
  def pattern; end
  def pattern=(_arg0); end
  def prefix(*args, **_arg1, &block); end
  def request_method(*args, **_arg1, &block); end
  def requirements(*args, **_arg1, &block); end
  def route_method; end
  def route_path; end
  def settings(*args, **_arg1, &block); end
  def translator; end
  def translator=(_arg0); end
  def version(*args, **_arg1, &block); end

  private

  def respond_to_missing?(method_id, _); end
  def warn_route_methods(name, location, expected = T.unsafe(nil)); end
end

Grape::Router::Route::FIXED_NAMED_CAPTURES = T.let(T.unsafe(nil), Array)
Grape::Router::Route::ROUTE_ATTRIBUTE_REGEXP = T.let(T.unsafe(nil), Regexp)
Grape::Router::Route::SOURCE_LOCATION_REGEXP = T.let(T.unsafe(nil), Regexp)

module Grape::ServeStream
  extend ::ActiveSupport::Autoload
end

Grape::ServeStream::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

class Grape::ServeStream::FileBody
  def initialize(path); end

  def ==(other); end
  def each; end
  def path; end
  def to_path; end
end

class Grape::ServeStream::SendfileResponse < ::Rack::Response
  def respond_to?(method_name, include_all = T.unsafe(nil)); end
  def to_path; end
end

class Grape::ServeStream::StreamResponse
  def initialize(stream); end

  def ==(other); end
  def stream; end
end

module Grape::Types; end
class Grape::Types::InvalidValue < ::Grape::Validations::Types::InvalidValue; end

module Grape::Util
  extend ::ActiveSupport::Autoload
end

class Grape::Util::BaseInheritable
  def initialize(inherited_values = T.unsafe(nil)); end

  def delete(key); end
  def inherited_values; end
  def inherited_values=(_arg0); end
  def key?(name); end
  def keys; end
  def new_values; end
  def new_values=(_arg0); end

  private

  def initialize_copy(other); end
end

class Grape::Util::Cache
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def cache; end

  class << self
    def [](*args, **_arg1, &block); end
    def cache(*args, **_arg1, &block); end
  end
end

class Grape::Util::EndpointConfiguration < ::Grape::Util::LazyValueHash; end

class Grape::Util::InheritableSetting
  def initialize; end

  def api_class; end
  def api_class=(_arg0); end
  def global; end
  def inherit_from(parent); end
  def namespace; end
  def namespace=(_arg0); end
  def namespace_inheritable; end
  def namespace_inheritable=(_arg0); end
  def namespace_reverse_stackable; end
  def namespace_reverse_stackable=(_arg0); end
  def namespace_stackable; end
  def namespace_stackable=(_arg0); end
  def parent; end
  def parent=(_arg0); end
  def point_in_time_copies; end
  def point_in_time_copies=(_arg0); end
  def point_in_time_copy; end
  def route; end
  def route=(_arg0); end
  def route_end; end
  def to_hash; end

  class << self
    def global; end
    def reset_global!; end
  end
end

class Grape::Util::InheritableValues < ::Grape::Util::BaseInheritable
  def [](name); end
  def []=(name, value); end
  def merge(new_hash); end
  def to_hash; end

  protected

  def values; end
end

class Grape::Util::LazyBlock
  def initialize(&new_block); end

  def evaluate; end
  def evaluate_from(configuration); end
  def lazy?; end
  def to_s; end
end

class Grape::Util::LazyObject < ::BasicObject
  def initialize(&callable); end

  def !; end
  def !=(other); end
  def ==(other); end
  def __target_object__; end
  def callable; end
  def method_missing(method_name, *args, &block); end

  private

  def respond_to_missing?(method_name, include_priv = T.unsafe(nil)); end
end

class Grape::Util::LazyValue
  def initialize(value, access_keys = T.unsafe(nil)); end

  def access_keys; end
  def evaluate; end
  def evaluate_from(configuration); end
  def lazy?; end
  def reached_by(parent_access_keys, access_key); end
  def to_s; end
end

class Grape::Util::LazyValueArray < ::Grape::Util::LazyValueEnumerable
  def initialize(array); end

  def evaluate; end
end

class Grape::Util::LazyValueEnumerable < ::Grape::Util::LazyValue
  def [](key); end
  def []=(key, value); end
  def fetch(access_keys); end
end

class Grape::Util::LazyValueHash < ::Grape::Util::LazyValueEnumerable
  def initialize(hash); end

  def evaluate; end
end

module Grape::Util::Registrable
  def default_elements; end
  def register(format, element); end
end

class Grape::Util::ReverseStackableValues < ::Grape::Util::StackableValues
  protected

  def concat_values(inherited_value, new_value); end
end

class Grape::Util::StackableValues < ::Grape::Util::BaseInheritable
  def [](name); end
  def []=(name, value); end
  def to_hash; end

  protected

  def concat_values(inherited_value, new_value); end
end

module Grape::Util::StrictHashConfiguration
  extend ::ActiveSupport::Concern

  class << self
    def config_class(*args); end
    def create_class_mod(args); end
    def module(*args); end
    def nested_settings_methods(setting_name, new_config_class); end
    def simple_settings_methods(setting_name, new_config_class); end
  end
end

module Grape::Util::StrictHashConfiguration::DSL
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Grape::Util::StrictHashConfiguration::DSL::ClassMethods
end

module Grape::Util::StrictHashConfiguration::DSL::ClassMethods
  def configure(&block); end
  def settings; end
end

class Grape::Util::StrictHashConfiguration::SettingsContainer
  def initialize; end

  def to_hash; end
end

Grape::VERSION = T.let(T.unsafe(nil), String)

module Grape::Validations
  class << self
    def deregister_validator(short_name); end
    def register_validator(short_name, klass); end
    def validators; end
    def validators=(_arg0); end
  end
end

class Grape::Validations::AttributesIterator
  include ::Enumerable

  def initialize(validator, scope, params); end

  def each(&block); end
  def scope; end

  private

  def do_each(params_to_process, parent_indicies = T.unsafe(nil), &block); end
  def skip?(val); end
  def yield_attributes(_resource_params, _attrs); end
end

class Grape::Validations::MultipleAttributesIterator < ::Grape::Validations::AttributesIterator
  private

  def yield_attributes(resource_params, _attrs); end
end

class Grape::Validations::ParamsScope
  include ::Grape::DSL::Parameters

  def initialize(opts, &block); end

  def brackets(val); end
  def configuration; end
  def element; end
  def element=(_arg0); end
  def full_name(name, index: T.unsafe(nil)); end
  def index; end
  def index=(_arg0); end
  def lateral?; end
  def meets_dependency?(params, request_params); end
  def nested?; end
  def parent; end
  def parent=(_arg0); end
  def required?; end
  def root?; end
  def should_validate?(parameters); end
  def type; end

  protected

  def full_path; end
  def push_declared_params(attrs, **opts); end

  private

  def all_element_blank?(scoped_params); end
  def check_coerce_with(validations); end
  def check_incompatible_option_values(default, values, except_values, excepts); end
  def coerce_type(validations, attrs, doc_attrs, opts); end
  def configure_declared_params; end
  def derive_validator_options(validations); end
  def document_attribute(attrs, doc_attrs); end
  def extract_message_option(attrs); end
  def guess_coerce_type(coerce_type, *values_list); end
  def infer_coercion(validations); end
  def new_group_scope(attrs, &block); end
  def new_lateral_scope(options, &block); end
  def new_scope(attrs, optional = T.unsafe(nil), &block); end
  def options_key?(type, key, validations); end
  def push_renamed_param(path, new_name); end
  def require_optional_fields(context, opts); end
  def require_required_and_optional_fields(context, opts); end
  def validate(type, options, attrs, doc_attrs, opts); end
  def validate_attributes(attrs, opts, &block); end
  def validate_value_coercion(coerce_type, *values_list); end
  def validates(attrs, validations); end
  def validates_presence(validations, attrs, doc_attrs, opts); end
end

class Grape::Validations::SingleAttributeIterator < ::Grape::Validations::AttributesIterator
  private

  def empty?(val); end
  def yield_attributes(val, attrs); end
end

module Grape::Validations::Types
  class << self
    def build_coercer(type, method: T.unsafe(nil), strict: T.unsafe(nil)); end
    def cache_instance(type, method, strict, &_block); end
    def cache_key(type, method, strict); end
    def collection_of_custom?(type); end
    def create_coercer_instance(type, method, strict); end
    def custom?(type); end
    def group?(type); end
    def map_special(type); end
    def multiple?(type); end
    def primitive?(type); end
    def special?(type); end
    def structure?(type); end
  end
end

class Grape::Validations::Types::ArrayCoercer < ::Grape::Validations::Types::DryTypeCoercer
  def initialize(type, strict = T.unsafe(nil)); end

  def call(_val); end

  protected

  def coerce_elements(collection); end
  def elem_coercer; end
  def reject?(val); end
  def subtype; end
end

class Grape::Validations::Types::CustomTypeCoercer
  def initialize(type, method = T.unsafe(nil)); end

  def call(val); end
  def coerced?(val); end

  private

  def enforce_symbolized_keys(type, method); end
  def infer_coercion_method(type, method); end
  def infer_type_check(type); end
  def recursive_type_check(type, value); end
  def symbolize_keys(hash); end
  def symbolize_keys!(hash); end
end

class Grape::Validations::Types::CustomTypeCollectionCoercer < ::Grape::Validations::Types::CustomTypeCoercer
  def initialize(type, set = T.unsafe(nil)); end

  def call(value); end
end

class Grape::Validations::Types::DryTypeCoercer
  def initialize(type, strict = T.unsafe(nil)); end

  def call(val); end

  protected

  def scope; end
  def strict; end
  def type; end

  class << self
    def coercer_instance_for(type, strict = T.unsafe(nil)); end
    def collection_coercer_for(type); end
    def register_collection(type); end

    protected

    def collection_coercers; end
  end
end

class Grape::Validations::Types::File
  class << self
    def parse(input); end
    def parsed?(value); end
  end
end

Grape::Validations::Types::GROUPS = T.let(T.unsafe(nil), Array)

class Grape::Validations::Types::InvalidValue
  def initialize(message = T.unsafe(nil)); end

  def message; end
end

class Grape::Validations::Types::Json
  class << self
    def parse(input); end
    def parsed?(value); end

    protected

    def coerced_collection?(value); end
  end
end

class Grape::Validations::Types::JsonArray < ::Grape::Validations::Types::Json
  class << self
    def parse(input); end
    def parsed?(value); end
  end
end

class Grape::Validations::Types::MultipleTypeCoercer
  def initialize(types, method = T.unsafe(nil)); end

  def call(val); end
end

Grape::Validations::Types::PRIMITIVES = T.let(T.unsafe(nil), Array)

class Grape::Validations::Types::PrimitiveCoercer < ::Grape::Validations::Types::DryTypeCoercer
  def initialize(type, strict = T.unsafe(nil)); end

  def call(val); end

  protected

  def reject?(val); end
  def treat_as_nil?(val); end
  def type; end
end

Grape::Validations::Types::PrimitiveCoercer::MAPPING = T.let(T.unsafe(nil), Hash)
Grape::Validations::Types::PrimitiveCoercer::STRICT_MAPPING = T.let(T.unsafe(nil), Hash)
Grape::Validations::Types::SPECIAL = T.let(T.unsafe(nil), Hash)
Grape::Validations::Types::STRUCTURES = T.let(T.unsafe(nil), Array)

class Grape::Validations::Types::SetCoercer < ::Grape::Validations::Types::ArrayCoercer
  def initialize(type, strict = T.unsafe(nil)); end

  def call(value); end

  protected

  def coerce_elements(collection); end
end

class Grape::Validations::Types::VariantCollectionCoercer
  def initialize(types, method = T.unsafe(nil)); end

  def call(value); end
end

class Grape::Validations::ValidatorFactory
  class << self
    def create_validator(**options); end
  end
end

module Grape::Validations::Validators; end

class Grape::Validations::Validators::AllOrNoneOfValidator < ::Grape::Validations::Validators::MultipleParamsBase
  def validate_params!(params); end
end

class Grape::Validations::Validators::AllowBlankValidator < ::Grape::Validations::Validators::Base
  def validate_param!(attr_name, params); end
end

class Grape::Validations::Validators::AsValidator < ::Grape::Validations::Validators::Base
  def validate_param!(*_arg0); end
end

class Grape::Validations::Validators::AtLeastOneOfValidator < ::Grape::Validations::Validators::MultipleParamsBase
  def validate_params!(params); end
end

class Grape::Validations::Validators::Base
  def initialize(attrs, options, required, scope, *opts); end

  def attrs; end
  def fail_fast?; end
  def message(default_key = T.unsafe(nil)); end
  def options_key?(key, options = T.unsafe(nil)); end
  def validate(request); end
  def validate!(params); end

  class << self
    def convert_to_short_name(klass); end
    def inherited(klass); end
  end
end

class Grape::Validations::Validators::CoerceValidator < ::Grape::Validations::Validators::Base
  def initialize(attrs, options, required, scope, **opts); end

  def validate_param!(attr_name, params); end

  private

  def coerce_value(val); end
  def converter; end
  def type; end
  def valid_type?(val); end
  def validation_exception(attr_name, custom_msg = T.unsafe(nil)); end
end

class Grape::Validations::Validators::DefaultValidator < ::Grape::Validations::Validators::Base
  def initialize(attrs, options, required, scope, **opts); end

  def validate!(params); end
  def validate_param!(attr_name, params); end

  private

  def duplicatable?(obj); end
  def duplicate(obj); end
end

class Grape::Validations::Validators::ExactlyOneOfValidator < ::Grape::Validations::Validators::MultipleParamsBase
  def validate_params!(params); end
end

class Grape::Validations::Validators::ExceptValuesValidator < ::Grape::Validations::Validators::Base
  def initialize(attrs, options, required, scope, **opts); end

  def validate_param!(attr_name, params); end
end

class Grape::Validations::Validators::MultipleParamsBase < ::Grape::Validations::Validators::Base
  def validate!(params); end

  private

  def all_keys; end
  def keys_in_common(resource_params); end
end

class Grape::Validations::Validators::MutualExclusionValidator < ::Grape::Validations::Validators::MultipleParamsBase
  def validate_params!(params); end
end

class Grape::Validations::Validators::PresenceValidator < ::Grape::Validations::Validators::Base
  def validate_param!(attr_name, params); end
end

class Grape::Validations::Validators::RegexpValidator < ::Grape::Validations::Validators::Base
  def validate_param!(attr_name, params); end
end

class Grape::Validations::Validators::SameAsValidator < ::Grape::Validations::Validators::Base
  def validate_param!(attr_name, params); end

  private

  def build_message; end
end

class Grape::Validations::Validators::ValuesValidator < ::Grape::Validations::Validators::Base
  def initialize(attrs, options, required, scope, **opts); end

  def validate_param!(attr_name, params); end

  private

  def check_excepts(param_array); end
  def check_values(param_array, attr_name); end
  def except_message; end
  def required_for_root_scope?; end
  def validation_exception(attr_name, message); end
end

Grape::Xml = ActiveSupport::XmlMini

module Rack
  class << self
    def release; end
    def version; end
  end
end

module Rack::Accept
  class << self
    def new(app, &block); end
  end
end

module Rack::Accept::Header
  include ::Rack::Accept::Header::PublicInstanceMethods

  private

  def join(qvalues); end
  def normalize_qvalue(q); end
  def parse(header); end
  def parse_media_type(media_type); end
  def parse_range_params(params); end

  class << self
    def join(qvalues); end
    def normalize_qvalue(q); end
    def parse(header); end
    def parse_media_type(media_type); end
    def parse_range_params(params); end
  end
end

Rack::Accept::Header::ALLOWED_CHARACTERS = T.let(T.unsafe(nil), Regexp)

class Rack::Accept::MediaType
  include ::Rack::Accept::Header::PublicInstanceMethods
  include ::Rack::Accept::Header

  def initialize(header); end

  def matches(media_type); end
  def name; end
  def parse_media_type(media_type); end
  def qvalue(media_type); end

  private

  def params_match?(params, match); end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)
