# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-types` gem.
# Please instead update this file by running `bin/tapioca gem dry-types`.

module Dry
  class << self
    def Equalizer(*keys, **options); end
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

module Dry::Types
  include ::Dry::Core::Constants
  extend ::Dry::Core::Deprecations::Interface
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Core::Extensions

  class << self
    def Rule(options); end
    def [](name); end
    def const_missing(const); end
    def container; end
    def define_builder(method, &block); end
    def identifier(klass); end
    def included(*_arg0); end
    def module(*args, &block); end
    def register(name, type = T.unsafe(nil), &block); end
    def registered?(class_or_identifier); end
    def rule_compiler; end
    def type_map; end
  end
end

Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)
Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)

class Dry::Types::AnyClass < ::Dry::Types::Nominal
  def initialize(**options); end

  def name; end
  def to_ast(meta: T.unsafe(nil)); end
  def with(**new_options); end

  class << self
    def name; end
  end
end

class Dry::Types::Array < ::Dry::Types::Nominal
  def constructor_type; end
  def of(type); end
end

class Dry::Types::Array::Constructor < ::Dry::Types::Constructor
  def constructor_type; end
  def lax; end
  def of(member); end
end

class Dry::Types::Array::Member < ::Dry::Types::Array
  def initialize(primitive, **options); end

  def call_safe(input); end
  def call_unsafe(input); end
  def constructor_type; end
  def lax; end
  def member; end
  def to_ast(meta: T.unsafe(nil)); end
  def try(input, &block); end
end

module Dry::Types::Builder
  include ::Dry::Core::Constants

  def <<(constructor = T.unsafe(nil), **options, &block); end
  def >>(constructor = T.unsafe(nil), **options, &block); end
  def append(constructor = T.unsafe(nil), **options, &block); end
  def constrained(options); end
  def constrained_type; end
  def constructor(constructor = T.unsafe(nil), **options, &block); end
  def constructor_type; end
  def default(input = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def enum(*values); end
  def fallback(value = T.unsafe(nil), shared: T.unsafe(nil), &_fallback); end
  def lax; end
  def optional; end
  def prepend(constructor = T.unsafe(nil), **options, &block); end
  def |(other); end
end

Dry::Types::Builder::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::Builder::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::Builder::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::Builder::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::Builder::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Types::Builder::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Types::Builder::Self = T.let(T.unsafe(nil), Proc)
Dry::Types::Builder::Undefined = T.let(T.unsafe(nil), Object)

module Dry::Types::BuilderMethods
  def Array(type); end
  def Constant(object); end
  def Constructor(klass, cons = T.unsafe(nil), &block); end
  def Hash(type_map); end
  def Instance(klass); end
  def Interface(*methods); end
  def Map(key_type, value_type); end
  def Nominal(klass); end
  def Strict(klass); end
  def Value(value); end
  def included(base); end
end

Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)

class Dry::Types::CoercionError < ::StandardError
  def initialize(message, meta: T.unsafe(nil), backtrace: T.unsafe(nil)); end

  def meta; end

  class << self
    def handle(exception, meta: T.unsafe(nil)); end
  end
end

module Dry::Types::Coercions
  include ::Dry::Core::Constants

  def to_date(input, &block); end
  def to_date_time(input, &block); end
  def to_symbol(input, &block); end
  def to_time(input, &block); end

  private

  def empty_str?(value); end
end

Dry::Types::Coercions::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::Coercions::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::Coercions::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::Coercions::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::Coercions::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Types::Coercions::IDENTITY = T.let(T.unsafe(nil), Proc)

module Dry::Types::Coercions::JSON
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    def to_decimal(input, &_block); end
    def to_nil(input, &_block); end
  end
end

module Dry::Types::Coercions::Params
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    def to_ary(input, &_block); end
    def to_decimal(input, &_block); end
    def to_false(input, &_block); end
    def to_float(input, &block); end
    def to_hash(input, &_block); end
    def to_int(input, &block); end
    def to_nil(input, &_block); end
    def to_true(input, &_block); end
  end
end

Dry::Types::Coercions::Params::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)
Dry::Types::Coercions::Params::FALSE_VALUES = T.let(T.unsafe(nil), Array)
Dry::Types::Coercions::Params::TRUE_VALUES = T.let(T.unsafe(nil), Array)
Dry::Types::Coercions::Self = T.let(T.unsafe(nil), Proc)
Dry::Types::Coercions::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Types::Constrained
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  def initialize(type, **options); end

  def ===(value); end
  def call_safe(input, &block); end
  def call_unsafe(input); end
  def constrained(options); end
  def constrained?; end
  def constructor_type; end
  def lax; end
  def rule; end
  def to_ast(meta: T.unsafe(nil)); end
  def try(input, &block); end

  private

  def decorate?(response); end
end

class Dry::Types::Constrained::Coercible < ::Dry::Types::Constrained
  def call_safe(input); end
  def call_unsafe(input); end
  def try(input, &block); end
end

class Dry::Types::ConstraintError < ::Dry::Types::CoercionError
  def initialize(result, input); end

  def input; end
  def message; end
  def result; end
  def to_s; end
end

class Dry::Types::Constructor < ::Dry::Types::Nominal
  def initialize(type, fn: T.unsafe(nil), **options); end

  def <<(new_fn = T.unsafe(nil), **options, &block); end
  def >>(new_fn = T.unsafe(nil), **options, &block); end
  def append(new_fn = T.unsafe(nil), **options, &block); end
  def call_safe(input); end
  def call_unsafe(input); end
  def constrained_type; end
  def constructor(new_fn = T.unsafe(nil), **options, &block); end
  def fn; end
  def lax; end
  def prepend(new_fn = T.unsafe(nil), **options, &block); end
  def to_ast(meta: T.unsafe(nil)); end
  def to_proc; end
  def try(input, &block); end
  def type; end

  private

  def method_missing(method, *args, &block); end
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    def [](type, fn:, **options); end
    def new(input, **options, &block); end
    def wrapper_type; end
  end
end

class Dry::Types::Constructor::Function
  include ::Dry::Core::Equalizer::Methods

  def initialize(fn); end

  def <<(other); end
  def >>(other); end
  def [](input, &block); end
  def arity; end
  def call(input, &block); end
  def fn; end
  def to_ast; end
  def wrapper?; end

  class << self
    def [](fn); end
    def yields_block?(fn); end
  end
end

class Dry::Types::Constructor::Function::MethodCall < ::Dry::Types::Constructor::Function
  def initialize(fn); end

  def name; end
  def target; end
  def to_ast; end

  class << self
    def [](fn, safe); end
    def call_class(method, public, safe); end
  end
end

class Dry::Types::Constructor::Function::MethodCall::PrivateCall < ::Dry::Types::Constructor::Function::MethodCall
  def call(input, &block); end
end

class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < ::Dry::Types::Constructor::Function::MethodCall::PrivateCall
  def call(input, &block); end
end

class Dry::Types::Constructor::Function::MethodCall::PublicCall < ::Dry::Types::Constructor::Function::MethodCall
  class << self
    def call_interface(method, safe); end
  end
end

class Dry::Types::Constructor::Function::Safe < ::Dry::Types::Constructor::Function
  def call(input, &block); end
end

class Dry::Types::Constructor::Function::Wrapper < ::Dry::Types::Constructor::Function
  def [](input, type, &block); end
  def arity; end
  def call(input, type, &block); end
end

module Dry::Types::Constructor::Wrapper
  def <<(new_fn = T.unsafe(nil), **options, &block); end
  def >>(constructor = T.unsafe(nil), **options, &block); end
  def append(constructor = T.unsafe(nil), **options, &block); end
  def call_safe(input, &block); end
  def call_unsafe(input); end
  def constructor(constructor = T.unsafe(nil), **options, &block); end
  def lax; end
  def prepend(new_fn = T.unsafe(nil), **options, &block); end
  def try(input, &block); end

  private

  def __new__(type); end
end

class Dry::Types::Container
  include ::Dry::Container::Mixin::Initializer
  include ::Dry::Container::Mixin
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  def config; end
end

module Dry::Types::Decorator
  include ::Dry::Types::Options

  def initialize(type, *_arg1, **_arg2); end

  def constrained?; end
  def default?; end
  def to_proc; end
  def try(input, &block); end
  def type; end

  private

  def __new__(type); end
  def decorate?(response); end
  def method_missing(meth, *args, **_arg2, &block); end
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

class Dry::Types::Default
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  def initialize(type, value, **options); end

  def call_safe(input = T.unsafe(nil), &block); end
  def call_unsafe(input = T.unsafe(nil)); end
  def callable?; end
  def constrained(*args); end
  def default?; end
  def evaluate; end
  def try(input); end
  def valid?(value = T.unsafe(nil)); end
  def value; end

  class << self
    def [](value); end
  end
end

class Dry::Types::Default::Callable < ::Dry::Types::Default
  def callable?; end
  def evaluate; end
end

Dry::Types::Definition = Dry::Types::Nominal
Dry::Types::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::EMPTY_STRING = T.let(T.unsafe(nil), String)

class Dry::Types::Enum
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder

  def initialize(type, **options); end

  def call_safe(input, &block); end
  def call_unsafe(input); end
  def default(*_arg0); end
  def include?(input = T.unsafe(nil)); end
  def inspect; end
  def inverted_mapping; end
  def mapping; end
  def to_ast(meta: T.unsafe(nil)); end
  def to_s; end
  def try(input); end
  def values; end

  private

  def map_value(input); end
end

class Dry::Types::FnContainer
  class << self
    def [](fn_name); end
    def container; end
    def register(function = T.unsafe(nil), &block); end
    def register_name(function); end
  end
end

class Dry::Types::Hash < ::Dry::Types::Nominal
  def constructor_type; end
  def map(key_type, value_type); end
  def permissive(*_arg0); end
  def schema(keys_or_map, meta = T.unsafe(nil)); end
  def strict(*_arg0); end
  def strict_with_defaults(*_arg0); end
  def symbolized(*_arg0); end
  def to_ast(meta: T.unsafe(nil)); end
  def transform_types?; end
  def weak(*_arg0); end
  def with_type_transform(proc = T.unsafe(nil), &block); end

  private

  def build_keys(type_map); end
  def key_name(key); end
  def resolve_type(type); end
end

class Dry::Types::Hash::Constructor < ::Dry::Types::Constructor
  def constructor_type; end
  def lax; end
  def schema(*args); end
end

Dry::Types::Hash::NOT_REQUIRED = T.let(T.unsafe(nil), Hash)
Dry::Types::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)

class Dry::Types::Lax
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  def [](input); end
  def call(input); end
  def call_safe(input); end
  def call_unsafe(input); end
  def lax; end
  def to_ast(meta: T.unsafe(nil)); end
  def try(input, &block); end

  private

  def decorate?(response); end
end

Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)

class Dry::Types::Map < ::Dry::Types::Nominal
  def initialize(_primitive, key_type: T.unsafe(nil), value_type: T.unsafe(nil), meta: T.unsafe(nil)); end

  def call_safe(hash); end
  def call_unsafe(hash); end
  def constrained?; end
  def key_type; end
  def name; end
  def to_ast(meta: T.unsafe(nil)); end
  def try(hash); end
  def value_type; end

  private

  def coerce(input); end
end

class Dry::Types::MapError < ::Dry::Types::CoercionError; end

module Dry::Types::Meta
  def initialize(*args, meta: T.unsafe(nil), **options); end

  def meta(data = T.unsafe(nil)); end
  def pristine; end
  def with(**options); end
end

class Dry::Types::MissingKeyError < ::Dry::Types::SchemaKeyError
  def initialize(key); end

  def key; end
end

class Dry::Types::Module < ::Module
  def initialize(registry, *args, **kwargs); end

  def registry_tree; end
  def type_constants(*namespaces, default: T.unsafe(nil), **aliases); end

  private

  def check_parameters(*namespaces, default: T.unsafe(nil), **aliases); end
  def define_constants(constants, mod = T.unsafe(nil)); end
end

class Dry::Types::MultipleError < ::Dry::Types::CoercionError
  def initialize(errors); end

  def errors; end
  def message; end
  def meta; end
end

Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)

class Dry::Types::Nominal
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  def initialize(primitive, **options); end

  def call_safe(input); end
  def call_unsafe(input); end
  def coerce(input, &_block); end
  def constrained?; end
  def default?; end
  def failure(input, error); end
  def lax; end
  def name; end
  def optional?; end
  def primitive; end
  def primitive?(value); end
  def success(input); end
  def to_ast(meta: T.unsafe(nil)); end
  def to_proc; end
  def try(input); end
  def try_coerce(input); end

  class << self
    def [](primitive); end
  end
end

Dry::Types::Nominal::ALWAYS = T.let(T.unsafe(nil), Proc)

module Dry::Types::Options
  def initialize(*args, **options); end

  def options; end
  def with(**new_options); end
end

Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

module Dry::Types::Printable
  def inspect; end
  def to_s; end
end

class Dry::Types::Printer
  def call(type); end
  def visit(type, &block); end
  def visit_any(_); end
  def visit_array(type); end
  def visit_array_member(array); end
  def visit_callable(callable); end
  def visit_constrained(constrained); end
  def visit_constructor(constructor); end
  def visit_default(default); end
  def visit_enum(enum); end
  def visit_hash(hash); end
  def visit_key(key); end
  def visit_lax(lax); end
  def visit_map(map); end
  def visit_nominal(type); end
  def visit_options(options, meta = T.unsafe(nil)); end
  def visit_schema(schema); end
  def visit_sum(sum); end
  def visit_sum_constructors(sum); end
end

Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)

class Dry::Types::Result
  include ::Dry::Core::Equalizer::Methods

  def initialize(input); end

  def input; end
end

class Dry::Types::Result::Failure < ::Dry::Types::Result
  def initialize(input, error); end

  def error; end
  def failure?; end
  def success?; end
  def to_s; end
end

class Dry::Types::Result::Success < ::Dry::Types::Result
  def failure?; end
  def success?; end
end

Dry::Types::Safe = Dry::Types::Lax

class Dry::Types::Schema < ::Dry::Types::Hash
  include ::Enumerable

  def initialize(_primitive, **options); end

  def apply(hash, options = T.unsafe(nil)); end
  def call_safe(hash, options = T.unsafe(nil)); end
  def call_unsafe(hash, options = T.unsafe(nil)); end
  def clear; end
  def constrained?; end
  def each(&block); end
  def key(name, fallback = T.unsafe(nil), &block); end
  def key?(name); end
  def keys; end
  def lax; end
  def merge(other); end
  def name_key_map; end
  def schema(keys_or_map); end
  def strict(strict = T.unsafe(nil)); end
  def strict?; end
  def to_ast(meta: T.unsafe(nil)); end
  def transform_key; end
  def transform_keys?; end
  def try(input); end
  def with_key_transform(proc = T.unsafe(nil), &block); end

  private

  def merge_keys(*keys); end
  def missing_key(key); end
  def resolve_missing_keys(hash, options); end
  def resolve_safe(hash, options = T.unsafe(nil), &block); end
  def resolve_unsafe(hash, options = T.unsafe(nil)); end
  def unexpected_keys(hash_keys); end
end

class Dry::Types::Schema::Key
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  extend ::Dry::Core::Deprecations::Interface

  def initialize(type, name, required: T.unsafe(nil), **options); end

  def call_safe(input, &block); end
  def call_unsafe(input); end
  def lax; end
  def meta(data = T.unsafe(nil)); end
  def name; end
  def omittable; end
  def optional; end
  def required(required = T.unsafe(nil)); end
  def required?; end
  def to_ast(meta: T.unsafe(nil)); end
  def try(input, &block); end

  private

  def decorate?(response); end
end

Dry::Types::Schema::NO_TRANSFORM = T.let(T.unsafe(nil), String)
Dry::Types::Schema::SYMBOLIZE_KEY = T.let(T.unsafe(nil), String)

class Dry::Types::SchemaError < ::Dry::Types::CoercionError
  def initialize(key, value, result); end
end

class Dry::Types::SchemaKeyError < ::Dry::Types::CoercionError; end
Dry::Types::Self = T.let(T.unsafe(nil), Proc)

class Dry::Types::Sum
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  def initialize(left, right, **options); end

  def call_safe(input, &block); end
  def call_unsafe(input); end
  def constrained(options); end
  def constrained?; end
  def default?; end
  def failure(input, _error = T.unsafe(nil)); end
  def left; end
  def meta(data = T.unsafe(nil)); end
  def name; end
  def optional?; end
  def primitive?(value); end
  def right; end
  def success(input); end
  def to_ast(meta: T.unsafe(nil)); end
  def to_proc; end
  def try(input); end
end

class Dry::Types::Sum::Constrained < ::Dry::Types::Sum
  def constrained?; end
  def rule; end
end

Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)

module Dry::Types::Type
  extend ::Dry::Core::Deprecations::Interface

  def ===(input = T.unsafe(nil)); end
  def [](input = T.unsafe(nil), &block); end
  def call(input = T.unsafe(nil), &block); end
  def safe(*args, &block); end
  def valid?(input = T.unsafe(nil)); end
end

Dry::Types::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Types::UnknownKeysError < ::Dry::Types::SchemaKeyError
  def initialize(keys); end

  def keys; end
end

Dry::Types::VERSION = T.let(T.unsafe(nil), String)
